Buffer Overflow – shellcode Injection
-------------------------------------

Description of the program:
---------------------------
To successfully exploit a buffer overflow vulnerability using shellcode injection, a command line application ToDo was chosen. ToDo is a simple command line task manager for Linux which is coded in the C programming language. 
To demonstrate the exploit, a vulnerable function strcpy was inserted in the “addTodo” function of the ToDo application. The strcpy copies our tainted buffer into the buffer ‘buf’ created under the addTodo function. Since the strcpy function does not check the number of bytes being copied, it successfully overflows the buffer and overwrites the return pointer with the address of our tainted buffer where the shellcode is present. 

Description of the exploit:
---------------------------
The shellcode injection exploit only works when a certain protection mechanisms like non-executable stack, address space randomization layout, stack canaries, etc. are not implemented on the system. These security mechanisms successfully protect the application from shellcode injection buffer overflow exploits. 
To successfully execute our exploit, we created our tainted buffer which consists of spacer bytes in the beginning (No-OP slides) followed by the shellcode and a number of return addresses. This return address was the starting address of our buffer space in the addTodo function. 
When the application returns from addTodo function and hits the “ret” statement, since the return address has already been corrupted with our tainted return address, the instruction pointer points to the start of our buffer instead of the next instruction in the main function. 
The starting of our buffer consists of the No-OP slide. These No-OP slide executes and finally hits the shellcode which gets executed, providing us with the shell access. 

Build Instruction for the vulnerable application:
-------------------------------------------------
Our exploit code has been written in the same todo.c file which consists of the application code. The exploit has been written under the main() function and the application’s main has been renamed to real_main(). 
The application consists of just one C file which can be compiled directly using GDB. 
To start the application, the first command that is executed is ./todo init which created a ToDo text repository where all tasks are stored. 

The application files are present under the VM’s folder /home/student/Documents/SVA-HW4/Shellcode_injection/ and also in this GitLab repository

Exploit demonstration:
----------------------
To run and successfully exploit the Todo application, follow the below steps:

1. Compile the program using the following command:

Gcc –m32 –z execstack –fno-stack-protector todo.c –o todo

2. Run the program by first entering  ./todo init to initiate the Todo repository and then ./todo add exploit *dummy address*
3. This will print out the start address of the buffer which consists of our tainted buffer.
4. This has been taken as a user input to successfully exploit the application since this address might change as stack changes on multiple execution
5. Take a note of the printbuf(shellcodeaddr) printed out in the previous command.
6. Compile the program again using the command in Step 2.
7. Run the program as:

./todo add exploit *address from step 6*

8. This will successfully exploit the program and provide you with the shell access. 

With ASLR is Turned ON:

With Address Space Layout Randomization turned on, every time the program is run, the stack space is shifted a bit. In such a case, it would be difficult for an attacker to calculate the correct starting address of the buffer at which the tainted buffer needs to be placed. The buffer’s starting address (which would replace the function’s return address) printed in Step 4 would be different from the address when the program is recompiled and run again leading to a failure in exploit. 
Even with this protection, an attacker could still exploit the application by using a brute force technique and trying multiple addresses till the shell access is obtained. Since the stack space does not move by large distances, it becomes easier for an attacker to still exploit the program.

Stack Canaries:

With stack canaries turned on, the system can identify if a buffer overflow exploit has been attempted and stops itself from executing the return statement. The stack canary value is checked right before the return statement is called. Due to buffer overflow, the value of the stack canary also changes and hence the check of the canary value fails, leading to the program halting and not executing the return statement.
To defeat this protection mechanism, multiple techniques can be used. First would be doing an arbitrary write to directly overwrite the return address with the address of the shellcode. Since the entire buffer is not corrupted, and subsequently not corrupting the canary value, the check canary test successfully passes leading to an execution to the return statement and successfully executing the shellcode. Second technique would be to calculate the canary value of the function and carefully placing it in the tainted buffer so that an overflow of the buffer does not corrupt the canary value, hence successfully passing the check canary test and executing the return statement. 
