Buffer Overflow – Arc Injection
-------------------------------

Description of the program:
---------------------------

To successfully exploit a buffer overflow vulnerability using arc injectin, a command line application ToDo was chosen. ToDo is a simple command line task manager for Linux which is coded in the C programming language. 
To successfully demonstrate this exploit, we injected a vulnerable strcpy function in the init() function of the application which copies our tainted buffer to the function’s buffer. Since strcpy does not check the number of bytes being copied from the source buffer, it ultimately leads to overflowing the buffer and corrupting the return address with the address of the system function call.
For return-into-libc, to bypass system’s stack protection mechanism, the shellcode was not provided as an input. Instead, the system function was used which in turn took /bin/sh as the argument and executed the shellcode. 

Description of the exploit:
---------------------------

In ToDo, the init() function is called to create a ToDo repository. This repository must be created for the application to run forward and log the task created by the user. The repository is a simple text file which keeps a track of all the tasks entered by the user and displays them when required. To create this repository, the command “./todo init” needs to be executed. 
Our exploit took advantage of this command and the file that is created. When the above command is executed, our exploit copies our tainted buffer to the text repository file. Now, when the user tries to enter any task, the first step the application does is execute the fileExists() function to check 
if the repository file has been created. When this happens, the fileExists() function reads from the the compromised file and the buffer overflow is executed, providing us with the shellcode. 

The distance at which the return address exists was calculated by a trial and error method by passing a string of A’s as the tainted buffer and observing the number of A’s sent before the program crashed trying to access an address of 0x41414141. 
This was the address at which the system function’s address had to be inserted.
The tainted buffer contains of the spacer in the beginning which is set of 28 No-OP slide, followed by the system() function’s address, the exit() function’s address and the address of /bin/sh.
The exit() function is used here so that when the user returns from the shellcode, the program exits gracefully. If there was no graceful shutdown, a core dump would be created which would log an entry in the system and hence provide as a proof of hack. The exit() function’s execution bypasses this.

Build Instructions of the vulnerable application:
-------------------------------------------------

This application consists of a single todo.c file which can be compiled in GCC (command mentioned in the exploit steps below) and run on the command line. 

Exploit demonstration steps:
----------------------------
1. Download the todo.c file onto your local computer (Linux based with version 14.04 or above)
2. Compile the application with the command:
Gcc –m32 –z execstack –fno-stack-protector
3. Initiate the ToDo’s repository text file by running:
./todo init
4. The above command successfully corrupts the repository text file with our tainted buffer.
5. The address of the system() function, exit() function and the /bin/sh was calculated by running the application binary in GDB and executing the below commands:

Print &system

print &exit

find &system,+9999999,"/bin/sh"  

These addresses are system dependent and do not change, hence has been hardcoded in the program. 

6. Now, any time the todo application is run, our malicious code calls this repository file and successfully overflows the buffer providing us with the shell access
7. This can be done by running Todo again:
./todo
