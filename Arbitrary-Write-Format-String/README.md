Arbitrary Write Exploit:
-------------------------

Description of program:
-----------------------

In order to demonstrate an arbitrary write exploit using the format string vulnerability, a command line application ToDo was selected. Todo
is a simple application coded in the C programming language whose main functionality is to manage tasks for the user. ToDo does so by logging
and keeping a track of the tasks created by the users.

Description of exploit:
-----------------------

The aim of this exploit was to perform an arbitrary write to directly overwrite the return address of the "deleteTodo" function with the address of our shell code.

In our exploit, we overwrote the "buf" in the addTodo function with our taintedbuffer in "todo" passed in as the argument. We used the "printf" funtion to exploit the program and pass in our tainted buffer from our exploit code to the deleteTodo's buffer.

The construction of our tainted buffer was done by taking in the the return address and the shellcode address as input from the user.
The code then calculates the decimal equivalent of the last two bytes of the shellcode address and replaces the respective bytes at the return address.
This is done using the %x to create an argument for the subsequent %hn (hn represents higher order bytes of a 4 bytes address).
A $ sign has also been used with %hn to indicate the offset from printf's internal pointer to the return address in order to perform the arbitrary write.
This helps in directly accessing the return address's memory location. (https://www.exploit-db.com/docs/28476.pdf)

Build Instructions of the vulnerable program:
--------------------------------------------
The exploit code has been added to the application's todo.c file. We have renamed the application's main() function to real_main() which consists the application program and our exploit code is added in the main() function.

The application is under the following directory: /home/student/Downloads/arb_write in the VM and also in this repository

Exploit demonstration:
----------------------

To run the program, and exploit the same, the following steps must be followed:

1. Compile the program using the following command: 

gcc -m32 -z execstack -fno-stack-protector -Wno-format-security todo.c -o todo

2. Since the return address and shellcode address can change with multiple execution of the application, we have coded the software to take the shellcode address and the return address as command line arguments.

3. To find the return address, open the todo.c file, locate the deleteTodo function and comment the "printf" statement.

4. Compile the program as above and run the program using the following command: 

./todo del *anyvalue*

5. The shellcode address and the return address will be printed out.

6. Go back to todo.c and uncomment the "printf" statement from the deleteTodo function

7. Compile the application as above and run the following command with the return address returned in the previous command:

./todo *shellcodeaddress* *returnaddress*

8. The exploit code then calculates the value to be passed in the printf statement to successfully overwrite the last 2 bytes of the return address with the shellcode address.
9. The above command execution should provide you with the shell access

9. To run the application in GDB, follow the same steps of uncommenting the "printf" statement, compile the program and run the program in GDB to get the new return address. 

10. Use this return address and run the program inside GDB with the same command as in step 7.

11. This should provide you with the shell access inside GDB.

12. Running the program with any other value or function runs the original application without any issues or exploits and hence the functionality of the application remain as is. 


Limitation of the exploit:
1. The code has been written to only overwrite two bytes (high order) of the return address. This is because in our environment there was only a need to change two high order bytes.
